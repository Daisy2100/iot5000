// package main

// import (
// 	"bytes"
// 	"context"
// 	"encoding/json"
// 	"fmt"
// 	"log"
// 	"math/rand"
// 	"net/http"
// 	"regexp"
// 	"sync"
// 	"time"

// 	"example.com/tool/format"
// 	initSetting "example.com/tool/init"
// 	"example.com/tool/models"
// )

// func generateURLs(startRange, endRange int, host string) []string {
// 	rand.Seed(time.Now().UnixNano()) // 初始化随机数生成器

// 	var urls []string
// 	minPort := 1
// 	maxPort := 5

// 	for i := startRange; i <= endRange; i++ {
// 		port := rand.Intn(maxPort-minPort+1) + minPort // 生成随机端口号
// 		url := fmt.Sprintf("http://%s:%d/equipment%d", host, 3000+port, i)
// 		urls = append(urls, url)
// 	}

// 	return urls
// }

// func main() {
// 	// 1-1. Read the config
// 	config, err := initSetting.ReadConfig("./config.json")
// 	if err != nil {
// 		log.Fatalf(err.Error())
// 	}

// 	// 1-2. Read the points
// 	points, err := initSetting.ReadPonit("./points.json")
// 	if err != nil {
// 		log.Fatalf(err.Error())
// 	}

// 	// 2. Create a context with timeout
// 	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(config.StartMinute)*time.Minute)
// 	defer cancel()

// 	// 3. Make the initial API request
// 	initialAPIURL := fmt.Sprintf("http://%s:3001/setInit/Daisy", config.GetDataApiHost)
// 	initialResponse, err := initSetting.MakeAPIRequest(initialAPIURL)
// 	if err != nil {
// 		log.Fatalf(err.Error())
// 	}
// 	fmt.Printf("Initial API response: %s\n", initialResponse)

// 	// 4. Create worker pools
// 	var wg sync.WaitGroup
// 	responseChan := make(chan models.SentData, config.BatchSize)

// 	// 這個 goroutine 是用於處理 read chan 資料

// 	var saveApiPath = fmt.Sprintf("http://%s:18080/rest/v2/insertRecords", config.SentDataApiHost)

// 	// 這個 goroutine 是用於處理 read chan 資料
// 	for i := 0; i < 5; i++ {
// 		go processChannel(responseChan, ctx.Done(), config.BatchSize, saveApiPath)
// 	}

// 	var urls = generateURLs(1, 5000, config.GetDataApiHost)
// 	for i := 0; i < config.SemaphoreForGet; i++ {
// 		for _, url := range urls {
// 			wg.Add(1)
// 			go func(url string) {

// 				defer wg.Done()
// 				for {
// 					select {
// 					case <-ctx.Done():
// 						return
// 					default:
// 						apiResp := sendHTTPRequest(url, *points)
// 						if apiResp != nil {
// 							fmt.Println("apiResp: ", apiResp)
// 							responseChan <- *apiResp // 寫入 chan
// 						}
// 					}
// 				}
// 			}(url)
// 		}
// 	}

// 	// 等待所有 workers 執行完畢
// 	wg.Wait()

// 	// close() 意思是禁止 chan 後續寫入但是可以讀取剩餘資料
// 	close(responseChan)

// 	fmt.Println("Final process remaining items in the channel...")
// 	// 關閉前最後剩下的一波資料(沒來得及搞完)
// 	// finalBatch := make([]models.SentData, 0)
// 	// for apiResp := range responseChan {
// 	// 	finalBatch = append(finalBatch, apiResp)
// 	// }
// 	// flushBatchData(&finalBatch)

// 	// 8. Make the final API request before stopping
// 	finalAPIURL := fmt.Sprintf("http://%s:3001/setFinal/Daisy", config.GetDataApiHost)
// 	finalResponse, err := initSetting.MakeAPIRequest(finalAPIURL)
// 	if err != nil {
// 		log.Fatalf(err.Error())
// 	}

// 	fmt.Printf("Final API response: %s\n", finalResponse)
// 	fmt.Println("Time's up!")
// }

// func sendHTTPRequest(url string, points models.ConfigPoint) *models.SentData {
// 	// 設置請求超時
// 	client := &http.Client{
// 		Timeout: 2 * time.Second,
// 	}

// 	resp, err := client.Get(url)
// 	if err != nil {
// 		fmt.Println("Error:", err)
// 		return nil
// 	}
// 	defer resp.Body.Close()

// 	if resp.StatusCode != http.StatusOK {
// 		return nil
// 	}

// 	var data map[string]float64
// 	if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
// 		return nil
// 	}

// 	equipmentName, err := extractEquipmentName(url)
// 	processedData := format.ProcessData(equipmentName, data, points)

// 	return &processedData
// }

// func processChannel(responseChan <-chan models.SentData, stop <-chan struct{}, BatchSize int, saveApiPath string) {

// 	batch := make([]models.SentData, 0, BatchSize)
// 	ticker := time.NewTicker(100 * time.Millisecond)
// 	defer ticker.Stop()

// 	for {
// 		select {
// 		case apiResp, ok := <-responseChan:
// 			if !ok {
// 				// Channel 以關閉, 最後一次處理 batch 剩餘資料
// 				flushBatchData(&batch, saveApiPath)
// 				return
// 			}
// 			// 將資料放入 batch 中
// 			batch = append(batch, apiResp)
// 			if len(batch) == BatchSize { // 達到 batch 最大水位資料時開閘放水
// 				flushBatchData(&batch, saveApiPath)
// 				batch = batch[:0] // 釋放記憶體以防 OOM
// 			}
// 		case <-ticker.C: // ticker 觸發，做滿水位同樣行為
// 			flushBatchData(&batch, saveApiPath)
// 			batch = batch[:0]
// 		case <-stop: // 停止運行，做滿水位同樣行為
// 			flushBatchData(&batch, saveApiPath)
// 			return
// 		}
// 	}
// }

// // Custom HTTP client with increased timeout and connection pooling
// var httpClient = &http.Client{
// 	Timeout: 2 * time.Second, // Increase timeout as needed
// 	Transport: &http.Transport{
// 		MaxIdleConns:        500,              // Increase the total number of idle connections
// 		MaxIdleConnsPerHost: 100,              // Increase the number of idle connections per host
// 		IdleConnTimeout:     90 * time.Second, // Set a reasonable timeout for idle connections
// 		DisableKeepAlives:   false,            // Ensure keep-alive connections are enabled
// 	},
// }

// func flushBatchData(batchResponseData *[]models.SentData, apiPath string) {
// 	if len(*batchResponseData) > 0 {
// 		// TODO 把這裡換成 save to db 的 code

// 		payload, err := json.Marshal(batchResponseData)
// 		if err != nil {
// 			fmt.Println("Error:", err)
// 		}

// 		req, err := http.NewRequest("POST", apiPath, bytes.NewBuffer(payload))
// 		if err != nil {
// 			fmt.Println("Error:", err)
// 		}
// 		req.Header.Set("Content-Type", "application/json")
// 		req.Header.Set("Authorization", "Basic cm9vdDpyb290")

// 		resp, err := httpClient.Do(req)
// 		if err != nil {
// 			fmt.Println("Error:", err)
// 			time.Sleep(2 * time.Second) // Exponential backoff can be implemented here
// 		}

// 		defer resp.Body.Close()
// 	}
// }

// func extractEquipmentName(url string) (string, error) {
// 	re := regexp.MustCompile(`equipment(\d+)`)
// 	matches := re.FindStringSubmatch(url)
// 	if len(matches) < 2 {
// 		return "", fmt.Errorf("unable to extract equipment name from URL: %s", url)
// 	}
// 	return "equipment" + matches[1], nil
// }
